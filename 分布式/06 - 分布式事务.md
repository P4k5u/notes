### 简介
事务是一个程序执行单元，里面的所有操作要么全部执行成功，要么全部执行失败。在分布式系统中，这些操作可能是位于不同的服务中，分布式事务就解决这个问题

单体应用：![[Pasted image 20240319111616.png]]

服务拆分：![[Pasted image 20240319111635.png]]

### 分布式事务体系
分布式的理论基础是 CAP，由于 P（分区容错）是必选项，所以只能是 AP 或 CP
- 分布式理论的 CP -> 刚性事务
	遵循ACID，对数据要求强一致性
- 分布式理论的 AP + BASE -> 柔性事务
	遵循BASE，允许一定时间内不同节点的数据不一致，但要求最终一致

分布式体系![[Pasted image 20240319112531.png]]
- 刚性事务
	- XA协议：
		- 二阶提交协议
		- 三阶提交协议
		- JTA
		- JTS
- 柔性事务
	- 补偿
		- TCC
		- SAGA
	- 最终一致性
		- 消息表
		- 消息队列
		- 最大努力通知
### 刚性事务

### 柔性事务

#### 补偿事务（TCC）
TTC（Try-Confirm-Cancel）又被称为补偿事务，TCC 与 2PC 的思想很相似，事务处理流程也很相似，但 2PC 是应用在 DB 层面，TCC 则可以理解为在应用层面的 2PC，需要编写业务逻辑来实现

TTC 的核心思想：”针对每一个操作都要注册一个与其对应的确认（Try）和补偿（Cancel）“

实现过程：[TCC分布式事务实现](https://www.cnblogs.com/jajian/p/10014145.html)
以下单扣库存为例：
- Try 阶段：下单时通过 Try 操作去扣库存预留资源（通过一个字段来表示冻结的库存）
- Confirm 阶段：确认执行业务操作，在预留的资源基础上，发起购买请求
- Cancel 阶段：只要设计到的相关业务中，有一个业务方预留资源未成功，则取消所有业务资源的预留请求![[Pasted image 20240319120135.png]]
TCC 的问题：
1、空回滚
- 起因：当一个分支事务所在的服务发生宕机或网络异常导致调用失败，并未执行 try 方法，当恢复后事务执行回滚操作就会调用分支事务的 cancel 方法，如果 cancel 方法不能处理此种情况就会出现空回滚
- 解决方案：是否出现空回滚，需要判断是否执行了 try 方法，解决方法就是当主业务发起事务时，生成一个全局事务记录，并生成一个全局唯一 ID ，再创建一张分支事务记录表，用于记录分支事务。try 执行时将全局事务 ID 和分支事务 ID 存入分支事务表中，表示执行了 try 阶段，当 cancel 执行时，先判断表中是否有该全局事务 ID 的数据，如果有则回滚，否则不做任何操作
2、幂等问题
- 起因：由于服务宕机或网络问题，方法的调用可能出现超时，为了保证事务正常执行往往会加入重试机制，所以需要保证 confirm 和 cancel 阶段操作的幂等性
- 解决方案：可以通过状态机来解决，在事务记录表中增加事务执行状态，每次执行 confirm 和 cancel 方法时都查询该事务的执行状态，以此判断事务的幂等性
3、悬挂问题
- 起因：TCC 中，调用 try 之前会先注册分支事务，注册分支事务之后，调用出现超时，此时 try 请求还未到达对应的服务，因为调用超时了，所有会执行 cancel 调用，此时 cancel 已经执行完了，然后这个时候 try 请求到达了，执行 try 之后没有后续的操作，导致资源挂起，无法释放
- 解决方案：同样用状态机解决，执行 try 方法时先判断 confirm 或 cancel 方法是否执行，如果执行了就不执行 try 阶段
#### SAGA 事务
SAGA 是由一系列的本地事务构成，每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发 SAGA 中的下一个本地事务执行。如果一个本地事务因为某些业务规则无法满足而失败，SAGA 会执行在失败事务之前的所有补偿操作

SAGA 的实现主要有两种方式：
- 基于事件的方式：处于当前Saga下的各个服务，会产生某类事件，或者监听其它服务产生的事件并决定是否需要针对监听到的事件做出响应
- 基于命令的方式：协调中心来告诉Saga的参与方应该执行哪一个本地事务

以订单流程为例，说明相关模式
一个完整的订单流程包含了如下几个服务：
1. Order Service：订单服务
2. Payment Service：支付服务
3. Stock Service：库存服务
4. Delivery Service：物流服务

##### 基于事件的方式
在基于事件的方式中，第一个服务执行完本地事务之后，会产生一个事件。其它服务会监听这个事件，触发该服务本地事务的执行，并产生新的事件

采用基于事件的 SAGA 模式的订单处理流程如下：![[Pasted image 20240319141931.png]]
1. 订单服务创建一笔新订单，将订单状态设置为"待处理"，产生事件ORDER_CREATED_EVENT。
2. 支付服务监听ORDER_CREATED_EVENT，完成扣款并产生事件BILLED_ORDER_EVENT。
3. 库存服务监听BILLED_ORDER_EVENT，完成库存扣减和备货，产生事件ORDER_PREPARED_EVENT。
4. 物流服务监听ORDER_PREPARED_EVENT，完成商品配送，产生事件ORDER_DELIVERED_EVENT。
5. 订单服务监听ORDER_DELIVERED_EVENT，将订单状态更新为"完成"

**该模式下的分布式事务回滚**
为了在异常情况下回滚整个分布式事务，我们需要为相关服务提供补偿操作接口。

假设库存服务由于库存不足没能正确完成备货，我们可以按照下面的流程来回滚整个Saga事务：![[Pasted image 20240319143212.png]]
1. 1. 库存服务产生事件PRODUCT_OUT_OF_STOCK_EVENT
2. 订单服务和支付服务都会监听该事件并做出响应：
	1. 支付服务完成退款。
	2. 订单服务将订单状态设置为"失败"

优点：简单易理解，参与方无直接沟通，完全解耦
缺点：业务多的情况下，容易失控
##### 基于命令的方式
在基于命令的方式中，会定义一个新的服务，这个服务扮演的角色就和一支交响乐乐队的指挥一样，告诉各个业务参与方，在什么时候做什么事情。这个服务叫做协调中心。协调中心通过命令/回复的方式来和 SAGA 中其他服务进行交互

引入协调中心 Order Saga Orchestrator![[Pasted image 20240319144312.png]]

#### 本地消息表
核心思路是将分布式事务拆分成本地事务进行处理

将业务分为 事务主动方 和 事务被动方
通过在事务发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息
事务被动方基于消息中间件消费事务消息表中的事务

整体流程如下：![[Pasted image 20240319145040.png]]
1、事务主动方在同一个本地事务中处理业务和写消息表操作
2、事务主动方通过消息中间件，通知事务被动方处理通知事务的消息。消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方主动写消息到消息队列，事务消费方消费并处理消息队列中的消息
3、事务被动方通过消息中间件，通知事务主动方事务已处理的消息
4、 事务主动方接收中间件的消息，更新消息表的状态为已处理

一些必要的容错处理如下：
- 当1处理出错，由于还在事务主动方的本地事务中，直接回滚即可
- 当2,3处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，事务被动方重新读取消息处理业务即可。
- 如果是业务上处理失败，事务被动方可以发消息给事务主动方回滚事务
- 如果事务被动方已经消费了消息，事务主动方需要回滚事务的话，需要发消息通知事务主动方进行回滚事务

#### MQ 事务方案
基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致

MQ事务方案整体流程和本地消息表的流程很相似，如下图：![[Pasted image 20240319151303.png]]
从上图可以看出和本地消息表方案唯一不同就是将本地消息表存在了MQ内部，而不是业务数据库中。

那么MQ内部的处理尤为重要，下面主要基于 RocketMQ 4.3 之后的版本介绍 MQ 的分布式事务方案。

在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ 的事务消息相对于普通 MQ提供了 2PC 的提交接口，方案如下：

**正常情况：事务主动方发消息**
![[Pasted image 20240319151523.png]]
事务主动方服务正常，没有发生故障，发消息流出如下：
- 发送方向 MQ 服务端（MQ Server）发送 half 消息
- MQ Server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功
- 发送方开始执行本地事务逻辑
- 发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或 rollback）
- MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息，MQ Server 收到 rollback 状态则删除 half 消息，订阅方将不会接受该消息

**异常情况：事务主动方消息恢复**
![[Pasted image 20240319152353.png]]
当网络问题或宕机等异常情况下，发送方提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：
- MQ Server 对该消息发起消息回查
- 发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果
- 发送方根据检查得到的本地事务最终状态再次提交二次确认

优点：消息数据独立存储，与业务解耦
缺点：一次消息发送需要两次网络请求（half + commit/rollback），业务方需要实现消息状态回查接口
#### 最大努力通知 
最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到消息，此时可以调用事务主动方提供的消息校对的接口主动获取

整体流程如下：![[Pasted image 20240319152827.png]]
在可靠消息事务中，事务主动方需要将消息发送出去，并且消息接收方成功接收，这种可靠性发送是由事务主动方保证的；

但是最大努力通知，事务主动方尽最大努力（重试，轮询....）将事务发送给事务接收方，但是仍然存在消息接收不到，此时需要事务被动方主动调用事务主动方的消息校对接口查询业务消息并消费，这种通知的可靠性是由事务被动方保证的。

最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口
### 分布式事务中间件

#### Seata
Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案