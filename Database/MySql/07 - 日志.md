### 简介
MySQL的逻辑框架如下：![[Pasted image 20240226104314.png]]
- 第一层：处理客户端连接、授权认证、安全校验等
- 第二层：服务器 Server 层，负责对 SQL 解释、分析、优化、执行操作引擎等
- 第三层：存储引擎，负责 MySQL 中数据的存储和提取

MySQL 数据更新流程如下：
![[Pasted image 20240226104311.png]]
update 语句的流程会涉及到 undo log（回滚日志）、redo log（重做日志）、binlog（归档日志）：
- undo log：是 InnoDB 存储引擎层生产的日志，实现了事务中的原子习惯，主要用于事务回滚和MVCC
- redo log：是 InnoDB 存储引擎层生产的日志，实现了事务的持久性，主要用于掉电等故障恢复
- binlog：是 Server 层生成的日志，主要用于数据备份和主从复制

### Buffer Pool
更新一条记录的时候，得先要从磁盘读取该记录，然后在内存中修改这条记录。修改完这条记录缓存起来，这样下次有查询语句命中了这条记录，直接读取缓存中的记录，就不需要从磁盘获取数据了

Innodb 存储引擎设计了一个**缓冲池（Buffer Pool）**，来提高数据库的读写性能![[Pasted image 20240226104915.png]]
- 当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。
- 当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘

### undo log
我们在执行执行一条“增删改”语句的时候，虽然没有输入 begin 开启事务和 commit 提交事务，但是 MySQL 会**隐式开启事务**来执行“增删改”语句的，执行完就自动提交事务的，这样就保证了执行完“增删改”语句后，我们可以及时在数据库表看到“增删改”的结果了

执行一条语句是否自动提交事务，是由 `autocommit` 参数决定的，默认是开启。所以，执行一条 update 语句也是会使用事务的

如果我们每次在事务执行过程中，都记录下回滚时需要的信息到一个日志里，那么在事务执行中途发生了 MySQL 崩溃后，就不用担心无法回滚到事务之前的数据，我们可以通过这个日志回滚到事务之前的数据

实现这一机制就是 undo log（回滚日志），它保证了事务的 原子性

undo log 记录的是数据修改前的状态，在数据修改的流程中，同时会记录一条与当前操作相反的逻辑日志到 undo log 中

此外 undo log 还有一个作用，通过 Read View + undo log 来实现 MVCC
### redo log
为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，**这个时候更新就算完成了**。

后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 **WAL （Write-Ahead Logging）技术**

**WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上**![[Pasted image 20240226105933.png]]

redo log 是物理日志，记录了某个数据页做了什么修改，比如**对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新**，每当执行一个事务就会产生这样的一条或者多条物理日志。

在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘

当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态

redo log 和 undo log 区别：
- redo log 记录了此次事务「**完成后**」的数据状态，记录的是更新**之后**的值
- undo log 记录了此次事务「**开始前**」的数据状态，记录的是更新**之前**的值
事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务
### binlog
MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。

binlog 文件是记录了所有数据库表结构变更和表数据修改的日志，不会记录查询类的操作，比如 SELECT 和 SHOW 操作

### 两阶段提交
事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态（只有其中一份日志刷入磁盘），这样就造成两份日志之间的逻辑不一致，导致主从环境的数据不一致

**MySQL 为了避免出现两份日志之间的逻辑不一致的问题，使用了「两阶段提交」来解决**

**两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」**

