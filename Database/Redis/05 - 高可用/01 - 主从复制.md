### 简介
主从复制，是指将一台 Redis 服务器的数据，复制到其他的 Redis 服务器。前者称为主节点（master），后者称为从节点（slave）。数据的复制是单向的，只能由主节点到从节点

主从服务器之间采用的是 读写分离 的方式：
- 主服务器可以进行读写操作，发生写操作是自动将写操作同步给从服务器
- 从服务器一般是只读，并执行主服务器同步的写操作
![[Pasted image 20231119134443.png]]
所有的数据修改只在主服务器上进行，然后同步最新数据给从服务器，保持主从的数据一致性

### 第一次同步（全量复制）
可以使用 replicaof 命令形成主服务器和从服务器的关系

比如：现有服务器 A 和服务器 B，在服务器 B 上执行下面这条命令：
```shell
#服务器 B 执行这条命令
replicaof <服务器 A 的 IP 地址> <服务器 A 的 Redis 端口号>
```
这样，服务器 B 就会变成服务器 A 的从服务器，然后与主服务器进行第一次同步

第一次同步的三个阶段：
- 第一阶段 -> 建立连接、协商同步
- 第二阶段 -> 主服务器同步数据给从服务器
- 第三阶段 -> 主服务器发送新写操作命令给从服务器
![[Pasted image 20231119150705.png]]

##### 第一阶段：建立链接、协商同步
执行了 replicaof 命令后，从服务器就会给主服务器发送 psync 命令，表示要进行数据同步

psync 命令包含两个参数，分别主服务器的 runID 和 复制进度 offset
- runID：每个 Redis 服务器在启动时都会自动生产一个随机的 ID 来唯一标识自己。当第一次同步时，设置为 "?"
- offset：表示复制的进度，第一次同步时，其值为 -1 

主服务器收到 psync 命令后，会用 FULLRESYNC 作为响应命令返回给从服务器，并且会带上 主服务器的runID 和主服务器目前的复制进度offset

从服务器收到这两个参数后会记录下来

##### 第二阶段：主服务器同步数据给从服务器
这时，主服务器会执行 bgsave 命令来生成 RDB 文件，然后把文件发送给从服务器

从服务器收到 RDB 文件后，会先清空当前的数据，然后载入 RDB 文件

为了保证主从服务器的数据一致性，主服务器在下面的三个时间间隙中将收到的写操作命令，写入到 replication buffer 缓冲区里：
- 主服务器生成 RDB 文件期间
- 主服务器发送 RDB 文件给从服务器期间
- 从服务器 加载 RDB 文件期间

##### 第三阶段：主服务器发送新写操作命令给从服务器
从服务器将 RDB 数据载入完之后，会回复一个确认消息给主服务器

主服务器将 replication buffer 缓冲区里所记录的写操作命令发送给从服务器，从服务器执行写命令来保持同步期间的数据一致性
### 命令传播
主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接![[Pasted image 20231119155020.png]]
主服务器通过长连接来持续向从服务器传输写操作命令，保持数据一致

这个过程被称为基于长连接的命令传播

### 主-从-从 模式
主从服务器在第一次数据同步的过程中，生成 RDB 文件和传输 RDB 文件

主服务器是可以有多个从服务器，如果从服务器数量非常多，而且都与主服务器进行全量同步的话，会十分消耗性能

当从服务器有自己的从服务器时，这样就可以把主服务器的数据同步给其他的从服务器![[Pasted image 20231119163410.png]]
通过这种方式，主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器

### 增量复制
如果主从库在命令传播时出现了网络闪断，那么主从库会采用增量的方式继续同步，把网络断开期间主服务器收到的写操作命令同步给从服务器

增量复制由三个部分组成：
- replication offset（复制偏移量）
- replication backlog（复制积压缓冲区）
- run ID（服务器的运行ID）
#### 复制偏移量
执行复制的双方，主从服务器会分别维护一个复制偏移量：
- master_repl_offset：主服务器每次向从服务器传播 N 个字节的数据时，就将自己的offset加上 N
- slave_repl_offset：从服务器每次收到主服务器的 N 个字节时，就将自己的 offset 加上 N
![[Pasted image 20231120145153.png]]

那么，通过对比主从服务器各自的offset，就可以判断是否处于数据一致的状态

#### 复制积压缓冲区
在主服务器进行命令传播时，不仅会把写命令发送给从服务器，还会把写命令写入到 repl_back_buffer 缓冲区里，这个缓冲区保存着最近传播的写命令![[Pasted image 20231120151923.png]]

网络断开后，当从服务器重新连上主服务器时，就会用 psync 命令将自己的复制偏移量 salve_repl_offset 发送给主服务器，主服务器就会检查 salve_repl_offset ：
- salve_repl_offset 之后的数据还在 repl_back_buffer 里时，就会发送 CONTINUE 回复，并把 master_repl_offset 到 salve_repl_offset 之间的数据写入 replication buffer（增量复制）
- 如果不存在时，就是网络断开时间太长，写命令全被覆盖了，就进行全量复制

为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，应该适当调整下 repl_backlog_buffer 缓冲区大小

### 读写分离
以主从复制为基础实现的读写分离，可以实现 Redis的读负载均衡，但是在使用时，需要注意一些问题

- 延迟与不一致问题
 优化主从节点之间的网络环境（如在同机房部署）；监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；使用集群同时扩展写负载和读负载等

- 数据过期问题
 Redis 3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端；将Redis升级到3.2可以解决数据过期问题

- 故障切换问题
 在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的Redis节点