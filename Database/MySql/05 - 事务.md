### 简介
数据库中的事务可以让所有的数据库操作都是不可分割的，要么全部执行成功，要么全部失败，不允许出现中间状态的数据
在操作前先开启事务，等所有数据库操作执行完成后，才提交事务，对于已经提交的事务来说，该事务对数据库所做的修改将永久生效，如果中途发生中断或错误，那么该事务期间对数据库所做的修改将会被回滚到没执行该事务之前的状态

### 事务特性
事务是由 MySQL 的引擎来实现的，常见的 InnoDB 引擎是可以支持事务的

不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务

实现事务需要遵守 4 个特性：
- 原子性：一个事务中的所有操作，要么全部完成，要么全部不完成
- 一致性：事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态
- 隔离性：数据库允许多个并发事务对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时产生的问题
- 持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会消失

InnoDB 引擎是怎么来保证事务特性：
- 持久性 -> 通过 redo log（重做日志）来保证
- 原子性 -> 通过 undo log（回滚日志）来保证
- 隔离性 -> 通过 MVCC（多版本并发控制）或锁 来保证
- 一致性 -> 保证 持久性 + 原子性 + 隔离性

### 并行事务
MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况

在同时处理多个事务的时候，就可能会出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题

#### 脏读
如果一个事务读取到另一个未提交事务修改过的数据，就意味着发生了脏读
例如：
![[Pasted image 20240225153359.png]]
因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，**如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读**
#### 不可重复读
在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了不可重复读现象
例如：![[Pasted image 20240225154019.png]]
**在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读**
#### 幻读
在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了幻读现象
例如：![[Pasted image 20240225154217.png]]

### 事务的隔离级别
多个事务并发时遇到的现象，会产生不同程度的影响
- 脏读：读到其他事务未提交的数据
- 不可重复读：前后读取的数据不一致
- 幻读：前后读取的记录数量不一致
这三个现象的严重性排序如下：
![[Pasted image 20240225154833.png]]
SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，四个隔离级别如下：
- 读未提交（read uncommitted）：指一个事务没提交时，它做的变更能被其他事务看到
- 读提交（read committed）：指一个事务提交之后，它做的变更才能被其他事务看到
- 可重复读（repeatable read）（默认）：指一个事务执行过程中看到的数据，一致跟这个事务启动时看到的数据时一致的
- 串行化（serializable）：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突，就必须等待完成
针对不同的隔离级别，并发事务时可能发生的现象也不同
![[Pasted image 20240225155431.png]]
MySQL InnoDB 引擎的默认隔离级别是 可重复读，但可以很大程度避免幻读现象，解决的方案有两种：
- 针对快照读（普通 select 语句）：通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题
- 针对当前读（select ... for update 等语句）：通过 next-key lock 方式解决了幻读，因为当执行 select ... for update 语句的时候，回加上 next-key lock，如果有其他事务在 next-key lock 范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，避免了幻读问题

四种隔离的事务的实现方式：
- 读未提交：读取最新数据
- 串行化：加锁
- 读提交、可重复读：通过 Read View 来实现，区别在于创建 Read View 的时机不同，Read View 相当于一个数据快照。读提交 是在每个语句执行前都会重新生成一个 Read View。可重复读 是在启动事务时 生成一个 Read View，整个事务期间都在用这个 Read View