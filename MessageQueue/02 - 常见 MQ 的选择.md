### 主流的MQ
#### RabbitMQ
RabbitMQ is the most widely deployed open source message broker.
AMQP 协议的标准实现者

优点：
1、Erlang 语言的加持
2、健壮、稳定、易用、支持多语言，文档齐全
3、管理 UI 舒服
4、社区活跃度高

缺点：
1、不支持重复消费
2、消息堆积过多时，性能表现不佳，应尽可能及时消费
3、依赖 HAProxy 做负载均衡
#### Kafka
Kafka 是一个开源的分布式事件流平台，成千上万的公司使用它来实现高性能数据管道，流分析，数据集成和关键人物应用程序
基于 TCP 定制的协议

依赖于 Zookeeper ，主要用于集群管理、配置管理、Leader 选举，是 Kafka 的一部分

优点：
1、消息可以重复消费
2、吞吐量高
3、社区超级活跃

缺点：
1、没有提高管控台
2、不支持死信队列，需要客户端手工实现
3、无延时队列

#### RocketMQ
RocketMQ 是一个统一的消息传递引擎，轻量级的数据处理平台
整体设计类似 kafka，扩展了很多功能，如：
1、支持 PUSH 模式
2、定制化的 NameServer（替换 zookeeper）
3、有自己的通信协议
4、支持消息过滤
5、单向消息
6、支持全局有序的消息
7、支持延时消息

### 消费方式
有两种方式：
1、Push 模型：当 Producer 发出的消息到达后，服务端马上将这条消息投递给 Consumer
2、Pull 模型：当服务端收到这条消息后什么也不做，等着 Conumser 主动到自己这里来读取，即 Conumser 有一个 拉取 动作

主流MQ的支持：
RabbitMQ -> PUSH/PULL
Kafka -> PULL
RocketMQ -> PUSH/PULL

push 模式很难适应消费速率不同的消费者，因为消息发送速率是由 broker 决定的，push 模式的目标是尽可能以最快速度传递消息，这样容易造成网络堵塞

### 相关名词
死信队列：消息没有消费者消费，消费者拒绝消费以及消费者不能处理的消息，会被入到死信队列
延时队列：设置延时时长，比如 5s，5s 之后消费者才能看到消息
重回队列：消费失败的情况下，将消息重新放入队列中，类似重试
消息确认：对于生产者来说，就是 Broker 是否收到；对于消费者来说，就是消费者是否收到
消息返回：消息不知道发给谁时进行监听