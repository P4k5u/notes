### 简介
Java 中的同步块用 synchronized 关键字标记。Java中的同步块在某个对象上同步。所有在相同对象上同步的同步块在同一时间只能有一个线程在其中执行。所有试图进入同步块的其他线程都会被阻塞，直到在同步块内的线程退出该块。

synchronized 关键字可以用来标记四种类型的块：
1. 实例方法
2. 静态方法
3. 实例方法中的代码块
4. 静态方法中的代码块
### 对象锁

#### 同步实例方法
代码如下：
```java
public class MyCounter {

  private int count = 0;

  public synchronized void add(int value){
      this.count += value;
  }
}
```
Java 中的同步实例方法在拥有该方法的实例（对象）上进行同步，因此每个实例的同步方法在不同的对象上同步
#### 同步实例方法中的代码块
可以不用同步整个方法，只同步方法中的某一段代码块：
```java
public void add(int value){

    synchronized(this){
       this.count += value;   
    }
  }
```
使用 synchronized 构造方法将代码块标记为同步。该代码块将和同步方法一下执行。传入 this 作为参数来获取该实例的监视器对象

### 类锁

#### 同步静态方法
代码如下：
```java
public static MyStaticCounter{

  private static int count = 0;

  public static synchronized void add(int value){
      count += value;
  }
}
```
同步静态方法作用在静态方法所属的类上，由于每个类的 JVM 中只存在一个类对象，因此只有一个线程可以在同一类中的静态同步方法执行
#### 同步静态方法中的代码块
代码如下：
```java
public class MyClass {  
    public static void log2(String msg1, String msg2){
       synchronized(MyClass.class){
          log.writeln(msg1);
          log.writeln(msg2);  
       }
    }
  }
```

### 四种锁状态
synchronized 是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是在 Java 对象头中。
所以，有两个概念需要知道，Java 对象头 和 Monitor
#### Java 对象头
以 Hotspot 虚拟机为例，Hotspot 的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）

Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息，运行期间 Mark Word 里存储的数据会随着锁标志位的变化而变化

Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
#### Monitor
Monitor 可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁

Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用

synchronized 通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的线程同步
频繁的阻塞或唤醒对于执行简单的代码内容来说未免效率过低，JDK 1.6 之前的 synchronized 效率低的原因就是如此。这种依赖于操作系统 Mutex Lock 所实现的锁就是 重量级锁
所以 JDK 对 synchronized 进行了优化，目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级，在mark word内容如下：![[Pasted image 20231220155412.png]]

**无锁**：
无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功

无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试

**偏向锁**：
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。

在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能

当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁

**轻量级锁**：
当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能

在代码进入同步块的时候，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。

拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。

如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态

如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。

若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁

**重量级锁**：
升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态