### 简介
熔断这一概念来源于电子工程中的断路器，在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用
### 熔断流程
#### 断路器模式
断路器有三种状态：关闭(closed)、开放(open)、半开放(half open)
- 最开始处于 closed 状态，一旦检测到错误达到阈值，转为 open 状态
- 这时会有个 reset timeout，即开始准备恢复服务了，转到 half-open 状态
- 尝试放行一部分请求到后端，一旦检测成功便回归到 closed 状态，恢复服务

![[Pasted image 20231110155155.png]]
这个原理，符合 fail fast 这个架构设计准则，而不是一直慢慢等待 fail，等到 fail 到一定程度后才暴露问题

For example:
订单服务(Order service) 调用 付款服务(payment service)

当没有故障，一切正常时，订单服务会通过断路器将所有的请求路由至付款服务![[Pasted image 20231110161512.png]]
当付款服务超时，断路器可以检测到超时并跟踪故障![[Pasted image 20231110161613.png]]
当超时超过指定的阈值，断路器就会启动，所有的请求就不会到达付款服务，当调用付款服务时，会立即返回失败/服务降级![[Pasted image 20231110161746.png]]
断路器会定时尝试放行一些请求查看付款服务的请求是否成功![[Pasted image 20231110161818.png]]
当付款服务的呼叫成功时，断路器将关闭，并且进一步将所有的请求放行![[Pasted image 20231110161913.png]]

值得注意的是，一个微服务可能会有多个实例，并不是所有实例都会出现故障，可能只是某个实例出现故障，而另一个却可以正常使用![[Pasted image 20231110164842.png]]
这样如果按照 ribbon 轮询的方式，那么轮询到 实例1 就会出现大量异常。在Spring Cloud中，为了避免这样的情况，Eureka 会通过服务续约机制探测到 实例1 不可用，把它从服务实例清单中剔除。
这样虽然避免了大量异常的发生，但是由于服务的实例少了，意味着服务能力下降，当并发请求增大时，单个实例的负荷可能会顶不住
### 相关组件

#### Hystrix
##### 简介
- 防止单个服务的故障导致其依赖和相关的服务容器的线程资源被耗尽
- 减少负载，并提供请求快速失败的功能，而不是让请求进行排队
- 尽可能提供服务降级的功能，让用户免受故障影响
- 使用隔离技术（如隔离板，泳道和断路器等）来限制某个服务出现问题所带来的影响
- 尽可能提供实时监控信息，通过监控和警报来优化发现故障的时间
- 允许使用配置修改相关参数
- 对服务调用消费者内部的故障进行保护
Hystrix 底层的实现是RxJava，它是流形式的，采用的是观察者模式

#### Sentinel