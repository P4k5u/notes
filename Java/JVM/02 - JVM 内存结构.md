### 简介
内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定来 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异

下面是 JVM 整体架构，中间部分就是 Java 虚拟机定义的各种运行时数据区域![[Pasted image 20240128195007.png]]
Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对一个的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁
- 线程私有：程序计数器、虚拟机栈、本地方法区
- 线程共享：堆、方法区、堆外内存（JDK 7 的永久代或 JDK 8 的元空间）

### 程序计数器
程序计数寄存器（Program Counter Register），Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的线程信息，CPU 只有把数据装载到寄存器才能够运行

这里，并非是广义上所指的物理寄存器，叫程序计数器（或PC计数器或指令计数器）会更加贴切，并且也不容易引起一些不必要的误会。JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟

程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器
#### 作用
PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令![[Pasted image 20240131162333.png]]


### 虚拟机栈
Java 虚拟机栈（Java Virtual Machine Stacks），早期也叫 Java 栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次 Java 方法调用，是线程私有的，生命周期和线程一致

主管 Java 程序的运行，它保存方法的局部变量、部分变量、并参与方法的调用和返回

JVM 直接对 虚拟机栈的操作只有两个：
- 方法执行时，入栈
- 执行结束后，出栈

栈不存在垃圾回收问题，每个线程都有自己的栈，栈中的数据以栈帧的格式存在，在这个线程上正在执行的每个方法都各自有对应的一个栈帧
#### 栈帧的内部结构
每个**栈帧**（Stack Frame）中存储着：
- 局部变量表（Local Variables）
- 操作数栈（Operand Stack）(或称为表达式栈)
- 动态链接（Dynamic Linking）：指向运行时常量池的方法引用
- 方法返回地址（Return Address）：方法正常退出或异常退出的地址
- 一些附加信息
![[Pasted image 20240131170112.png]]
##### 局部变量表
局部变量表也被称为局部变量数组或本地变量表，这是一组变量值存储空间，主要用于存储方法参数和定义在放题内的局部变量，包括编译器可知的各种 Java 虚拟机基本数据类型（boolean、byte、char 等）、对象引用（一个指向对象初始地址的引用指针，也可能是指向一个代表对象的句柄）等

由于局部变量表是建立在线程的栈上，是线程的私有数据，因此**不存在数据安全问题**

局部变量表所需要的容量大小是编译期确定下来的，表中的变量只在当前方法调用中有效

##### 槽 Slot
局部变量表最基本的存储单元是 变量槽 （Slot）
32 位以内的类型只占用一个 Slot ，64 位的类型占用两个连续的 Slot

JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值，索引值的范围从 0 开始到局部变量表最大的 Slot 数量

当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会**按照顺序被复制**到局部变量表中的每一个 Slot 上
**如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可**

**栈帧中的局部变量表中的槽位是可以重用的**，在局部变量过了作用域之后，那么新的局部变量就会复用它的槽![[Pasted image 20240131172431.png]]

在栈帧中，与性能调优关系最为密切的就是局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递

**局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收**
##### 操作数栈
每个独立的栈帧中除了包含局部变量表之外，还包含一个**后进先出**（Last-In-First-Out）的操作数栈，也可以称为**表达式栈**（Expression Stack）
**操作数栈，在方法执行过程中，根据字节码指令，往操作数栈中写入数据或提取数据，即入栈（push）、出栈（pop）**

操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间

##### 动态链接
动态链接指向运行时常量池的方法引用，每一个栈帧内部都包含一个指向运行常量池中该栈帧所属方法的引用，这可以支持当前方法的代码能够实现动态链接

在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为 符号引用（Symbolic Reference）保存在 Class 文件的常量池中。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么**动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**
![[Pasted image 20240131173924.png]]

##### 方法返回地址

##### 附加信息

### 本地方法栈

#### 本地方法接口
简单的讲，一个 Native Method 就是一个 Java 调用非 Java 代码的接口。我们知道的 Unsafe 类就有很多本地方法

Java 虚拟机栈用于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用
本地方法栈也是线程私有的
在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一
### 堆内存

#### 内存划分
对于大多数应用，Java 堆是 Java 虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。

为了进行高效的垃圾回收，虚拟机把堆内存逻辑上划分成三块区域（分代的唯一理由就是优化 GC 性能）：
- 新生代：新对象和没达到一定年龄的对象都在新生代
- 老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大
- 元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存
![[Pasted image 20240220163138.png]]
Java 虚拟机规范规定，Java 堆可以是处于物理上不连续的内存空间中，只要逻辑上是连续的即可，像磁盘空间一样。实现时，既可以是固定大小，也可以是可扩展的，主流虚拟机都是可扩展的（通过 `-Xmx` 和 `-Xms` 控制），如果堆中没有完成实例分配，并且堆无法再扩展时，就会抛出 `OutOfMemoryError` 异常
##### 新生代（Young Generation）
新生代是所有新对象创建的地方。当充满新生代时，执行垃圾收集。这种垃圾收集称为 Minor GC。新生代被分为三个部分 —— 伊甸园（Eden Memory）和两个幸存区（Survivor Memory，被称 from/to 或 s0/s1），默认比例是 8:1:1
- 大多数新创建的对象都位于 Eden 内存空间
- 当 Eden 空间被对象填充时，执行 Minor GC，并将所有幸存者对象移动到一个幸存者空间中
- Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间，所以每次 GC 之后总有一个幸存者空间是空的
- 经过多次 GC 循环后存活下来的对象被移动到老年代，通常这是通过设置新生代对象的阈值来实现，然后才提升到老年代

##### 老年代（Old Generation）
老年代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集也称为 Major GC，通常需要更长的时间。

大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝
![[Pasted image 20240220165708.png]]
##### 元空间（MetaSpace）
不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中方法区的实现

虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 Non-Heap（非堆），目的应该是与 Java 堆区分开

#### 对象生命周期
1、在 JVM 内存模型的堆中，堆被划分为新生代和老年代
- 新生代又被进一步划分为 Eden 区 和 Survivor区，Survivor 区由 From Survivor 和 To Survivor 组成
2、当创建一个对象时，对象会被优先分配到新生代的 Eden 区
- 此时 JVM 会给对象定义一个对象年轻计数器（-XX:MaxTenuringThreshold）
3、当 Eden 空间不足时，JVM 将执行新生代的垃圾回收（Minor GC）
- JVM 会把存活的对象转移到 Survivor 中，并且对象年龄 +1
- 对象在 Survivor 中同样也会经历 Minor GC，每经历一次 Minor GC，对象年龄都会 +1
4、如果分配的对象超过了-XX:PetenureSizeThreshold，对象会直接被分配到老年代

#### 对象分配过程
堆空间的基本结构：![[Pasted image 20240220170658.png]]
- 上图所示的 Eden 区、From Survivor0("From") 区、To Survivor1("To") 区都属于新生代，Old Memory 区属于老年代  
- 大部分情况，对象都会首先在 Eden 区分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过-XX:+PrintTenuringDistribution来打印出当次GC后的Threshold  
    - 年龄阈值：Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值  
- 经过这次 GC 后，Eden 区和"From"区已经被清空。这个时候，"From"和"To"会交换他们的角色，也就是新的"To"就是上次 GC 前的“From”，新的"From"就是上次 GC 前的"To"。不管怎样，都会保证名为 To 的 Survivor 区域是空的。Minor GC会一直重复这样的过程，在这个过程中，有可能当次Minor GC后，Survivor 的"From"区域空间不够用，有一些还达不到进入老年代条件的实例放不下，则放不下的部分会提前进入老年代（分配担保机制）

#### GC 垃圾回收
VM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。

HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：
- Partial GC：收集部分GC堆的模式
    - Young GC：只收集 young gen 的 GC，Young GC 还有种说法就叫做 Minor GC
    - Old GC：只收集 old gen 的GC。（只有 CMS 的 concurrent collection 是这个模式）
    - Mixed GC：收集整个 young gen 以及部分 old gen 的GC（只有 G1 有这个模式）
- Full GC：收集整个堆，包括 young gen、old gen、perm gen（如果存在的话）等所有部分的模式

Major GC 通常是跟 full GC 是等价的，收集整个GC堆。但因为 HotSpot VM 发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候要分清楚指的是 Old GC 还是 full GC

分代式 GC 策略，按HotSpot VM的 serial GC 的实现来看，触发条件是：
- young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高
- full GC：当准备要触发一次 young GC 时，如果发现统计数据说之前young GC的平均晋升大小比目前 old gen 剩余的空间大，则不会触发 young GC 而是转为触发full GC
### 方法区
方法区和 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名 Non-Heap（非堆），为的是跟堆区分

#### 方法区和永久代的关系
《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现

#### 为什么将永久代（PermGen）替换为元空间（MetaSpace）
1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小  
2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 MaxPermSize 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了  
3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了

#### 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分

`Class文件`中除了有类的版本、字段、方法、接口等描述信息外，还有常量池

##### 常量池
一个 Java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候用到的就是运行时常量池

常量池用于存放编译期生成的各种字面量和符号引用，将在类加载后进入方法区的运行时常量池中存放
- 字面量：文本字符串、被声明为 final 的常量、基本数据类型的值
- 符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符
注意：
1、这里的运行时常量池是属于方法区中的概念，而常量池（包含基本类型和字符串）是属于`Class文件`的，只是类加载时被放到运行时常量池中![[Pasted image 20240220174027.png]]
2、当`Class文件`的常量池被加载进运行时常量池后，常量池中的字符串常量引用要与字符串常量池中的引用保持一致
