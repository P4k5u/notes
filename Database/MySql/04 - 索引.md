### 简介
索引 是一种用于快速查询和检索数据的数据结构，相当于是数据的目录
### InnoDB 的索引方案
InnoDB 使用数据页来存放记录，一个数据页最大为 16 KB，也就是说最多可以保证 16KB 的连续存储空间
定义一个 c1、c2、c3 的表，那么一条记录的结构如下：![[Pasted image 20240224174153.png]]
- record_type：表示记录的类型，0 表示普通记录，1 表示目录项记录，2 表示最小记录，3 表示最大记录
- next_record：表示下一条地址相对于本条记录的地址偏移量
- 各个列的值：比如 c1、c2、c3 的值
- 其他信息：包括其他隐藏列以及记录的额外信息
那么一个页中的记录结构如下：![[Pasted image 20240224174415.png]]
数据页中的记录主键值必须要按照 从小到大 排序![[Pasted image 20240224181335.png]]
现在假设每个页最多只能放 3 个记录，那么就得分配多一个新页来存放新的记录：![[Pasted image 20240224181525.png]]
注意，这里的新增的 页28 并不是 页11 ，因为分配的数据页是保证逻辑上是连续的，物理上不一定连续
而 页28 中的主键值为 4，页10 中的最后一条记录主键为 5，所以要进行一次移动，把 4 和 5 的记录交换，这就是 页分裂![[Pasted image 20240224181750.png]]
在插入多条记录后，会是这样的效果![[Pasted image 20240224181829.png]]
这是就需要用目录来进行快速定位，每个目录项包含两部分：
- 页中的最小主键值，用 key 表示
- 页号，用 page_no 表示
构建好目录项之后的结构如下所示：![[Pasted image 20240224182003.png]]
而这些目录项就是 索引

利用记录头中 record_type 这个字段来区分该记录是目录项记录还是普通记录，并且也放入到页中，那么就如下所示：![[Pasted image 20240224182141.png]]
当目录项变多的时候，会分配一个更高级的目录项，为存储 目录项记录 的页再生成更高级的目录项
![[Pasted image 20240224195757.png]]
这样，就形成了一个树形结构，就是 B+ 树
不论是存放普通记录的数据页，还是存放目录项记录的数据页，都存放在 B+ 树这个数据结构中，这些数据就是其中的节点
### 索引的分类

#### 按物理存储分类
##### 聚簇索引
把具有这两种特性的`B+`树称为`聚簇索引`
- 使用主键值的大小进行记录和页的排序
- 叶子节点存储的是普通记录
所有的普通记录都存放在这个`聚簇索引`的叶子节点处

这种`聚簇索引`并不需要我们在`MySQL`语句中显式的使用`INDEX`语句去创建（后边会介绍索引相关的语句），`InnoDB`存储引擎会自动的为我们创建聚簇索引。另外有趣的一点是，在`InnoDB`存储引擎中，`聚簇索引`就是数据的存储方式（所有的用户记录都存储在了`叶子节点`），也就是所谓的索引即数据，数据即索引
##### 二级索引
聚簇索引 只能在搜索条件是 主键值 时才能发挥作用，因为 B+ 树中都是按照主键进行排序的
当用非主键的列作为搜索条件时，可以构建 二级索引 的 B+ 树
- 使用 非主键 的列进行记录和页的排序
- B+ 树的叶子节点不是完整的记录，而只是 非主键 + 主键 这两个列的值
- 目录项不再是 主键 + 页号，而是 主键值 + 非主键 + 页号，为的是保证唯一性
以 c2 列为例，再建一颗 B+ 树：![[Pasted image 20240224202957.png]]

但是使用二级索引的过程中，因为叶子节点保存的不是完整记录，所以查找到对应记录的主键后，还要再去 聚簇索引 进行第二次查找，这种过程被称为 回表 ，每次查找都需要用到 2 棵 B+ 树
##### 联合索引
可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让`B+`树按照`c2`和`c3`列的大小进行排序，这个包含两层含义：
- 先把各个记录和页按照`c2`列进行排序。
- 在记录的`c2`列相同的情况下，采用`c3`列进行排序
构建的联合索引 B+ 树 如下所示：![[Pasted image 20240224203323.png]]


#### 按字段特性分类

##### 主键索引
主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。

在创建表时，创建主键索引的方式如下：
```mysql
CREATE TABLE table_name  (
  ....
  PRIMARY KEY (index_column_1) USING BTREE
);
```
##### 唯一索引
唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。

在创建表时，创建唯一索引的方式如下：
```mysql
CREATE TABLE table_name  (
  ....
  UNIQUE KEY(index_column_1,index_column_2,...) 
);
```
建表后，如果要创建唯一索引，可以使用这面这条命令：
```mysql
CREATE UNIQUE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```
##### 普通索引
普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。

在创建表时，创建普通索引的方式如下：
```mysql
CREATE TABLE table_name  (
  ....
INDEX(index_column_1,index_column_2,...) 
);
```
建表后，如果要创建普通索引，可以使用这面这条命令：
```mysql
CREATE INDEX index_name
ON table_name(index_column_1,index_column_2,...); 
```
##### 前缀索引
前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。

使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。

在创建表时，创建前缀索引的方式如下：
```mysql
CREATE TABLE table_name(
    column_list,
    INDEX(column_name(length))
); 
```
建表后，如果要创建前缀索引，可以使用这面这条命令：
```mysql
CREATE INDEX index_name
ON table_name(column_name(length)); 
```

#### 按字段个数分类
从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）
- 建立在单列上的索引称为单列索引，比如主键索引
- 建立在多列上的索引称为联合索引

##### 联合索引
通过将多个字段组合成一个索引，该索引就被称为联合索引。

比如，将商品表中的 product_no 和 name 字段组合成联合索引`(product_no, name)`，创建联合索引的方式如下：
```mysql
CREATE INDEX index_product_no_name ON product(product_no, name);
```

使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了

比如，如果创建了一个 `(a, b, c)` 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：

- where a=1；
- where a=1 and b=2 and c=3；
- where a=1 and b=2；

需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。

但是，如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:

- where b=2；
- where c=3；
- where b=2 and c=3；

上面这些查询条件之所以会失效，是因为`(a, b, c)` 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，**b 和 c 是全局无序，局部相对有序的**，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的